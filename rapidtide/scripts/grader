#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2019 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# $Author: frederic $
# $Date: 2016/07/11 14:50:43 $
# $Id: tidepool,v 1.28 2016/07/11 14:50:43 frederic Exp $
#
# -*- coding: utf-8 -*-

"""
A simple GUI for looking at the results of a rapidtide analysis
"""

from __future__ import print_function, division

from pyqtgraph.Qt import QtGui, QtCore

import pyqtgraph as pg
import numpy as np
import glob

import rapidtide.stats as tide_stats
import rapidtide.io as tide_io
import rapidtide.filter as tide_filt
import rapidtide.miscmath as tide_math
import rapidtide.util as tide_util
from rapidtide.workflows.parser_funcs import (is_valid_file, invert_float, is_float)
import sys
import argparse
import os
import pandas as pd
from statsmodels.robust.scale import mad

import rapidtide.graderTemplate as uiTemplate


class KeyPressWindow(QtGui.QMainWindow):
    sigKeyPress = QtCore.pyqtSignal(object)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def keyPressEvent(self, ev):
        self.sigKeyPress.emit(ev)


def incrementgrade(whichfile):
    global alldata, filelist

    if alldata[filelist[whichfile]]['grade'] is None:
        alldata[filelist[whichfile]]['grade'] = 1
    else:
        alldata[filelist[whichfile]]['grade'] += 1


def decrementgrade(whichfile):
    global alldata, filelist

    if alldata[filelist[whichfile]]['grade'] is None:
        alldata[filelist[whichfile]]['grade'] = -1
    else:
        alldata[filelist[whichfile]]['grade'] -= 1

def writegrades():
    global alldata, filelist, numfiles, outputfile

    with open(outputfile, 'w') as thefile:
        for i in range(len(filelist)):
            if alldata[filelist[i]]['grade'] is not None:
                thefile.write('{0}, {1}\n'.format(filelist[i], alldata[filelist[i]]['grade']))


def keyPressed(evt):
    global whichfile, numfiles

    if evt.key() == QtCore.Qt.Key_Up:
        incrementgrade(whichfile)
    elif evt.key() == QtCore.Qt.Key_Down:
        decrementgrade(whichfile)
    elif evt.key() == QtCore.Qt.Key_Left:
        whichfile = (whichfile - 1) % numfiles
    elif evt.key() == QtCore.Qt.Key_Right:
        whichfile = (whichfile + 1) % numfiles
    elif evt.key() == QtCore.Qt.Key_Escape:
        writegrades()
        print('done')
    else:
        print(evt.key())

    updateTimecourse()


def selectFile():
    global datafileroot
    mydialog = QtGui.QFileDialog()
    options = mydialog.Options()
    lagfilename = mydialog.getOpenFileName(options=options, filter="Lag time files (*_lagtimes.nii.gz)")[0]
    datafileroot = str(lagfilename[:-15])


def logstatus(thetextbox, thetext):
    thetextbox.moveCursor(QtGui.QTextCursor.End)
    thetextbox.insertPlainText(thetext + '\n')
    sb = thetextbox.verticalScrollBar()
    sb.setValue(sb.maximum())


# found this routine at https://github.com/abhilb/pyqtgraphutils/blob/master/pyqtgraphutils.py
class RectangleItem(pg.GraphicsObject):
    def __init__(self, topLeft, size, color=(0, 128, 0, 128)):
        pg.GraphicsObject.__init__(self)
        self.topLeft = topLeft
        self.size = size
        self.color = color
        self.generatePicture()

    def generatePicture(self):
        self.picture = QtGui.QPicture()
        p = QtGui.QPainter(self.picture)
        p.setPen(pg.mkPen(self.color))
        p.setBrush(pg.mkBrush(self.color))
        tl = QtCore.QPointF(self.topLeft[0], self.topLeft[1])
        size = QtCore.QSizeF(self.size[0], self.size[1])
        p.drawRect(QtCore.QRectF(tl, size))
        p.end()

    def paint(self, p, *args):
        p.drawPicture(0, 0, self.picture)

    def boundingRect(self):
        return QtCore.QRectF(self.picture.boundingRect())


def updateTimecourse():
    global timecourse_ax, whichfile, alldata, filelist, win, numfiles
    thisfile = alldata[filelist[whichfile]]
    windowtitle = 'Grader - {0} ({1} of {2})'.format(filelist[whichfile], whichfile, numfiles)
    win.setWindowTitle(windowtitle)

    if thisfile['grade'] is None:
        pencolor = 'w'
    elif thisfile['grade'] == 0:
        pencolor = 'w'
    elif thisfile['grade'] > 0:
        pencolor = 'g'
    else:
        pencolor = 'r'

    timecourse_ax.plot(thisfile['timeaxis'], thisfile['timecourse'],
                      stepMode=False, fillLevel=0, pen=pg.mkPen(pencolor, width=1), clear=True)

    if thisfile['grade'] is None:
        thelabel = 'Grade: None'
    else:
        thelabel = 'Grade: {0}'.format(thisfile['grade'])

    spectrum_ax.plot(thisfile['freqaxis'], thisfile['spectrum'],
                     name=thelabel,
                     stepMode=False,
                     fillLevel=0,
                     pen=pg.mkPen(pencolor, width=1),
                     clear=True)

    spectop = 1.25 * np.max(thisfile['spectrum'])
    spectrum_ax.setYRange(0.0, spectop, padding=0)


    #text = pg.TextItem(text=thelabel,
    #                   anchor = (0.0, 1.0),
    #                   angle = 0,
    #                   fill = (0, 0, 0, 100))
    #spectrum_ax.addItem(text)
    spectrum_ax.addLegend(offset=(200, 30))


def main():
    global ui, win
    global filelist, outputfile, alldata, whichfile, numfiles

    parser = argparse.ArgumentParser(description='A program to sort through timecourses and assign grades')
    parser.add_argument('filespec',
                        type=str,
                        help='A regex (with path) that will select files.  Should be enclosed in quotes')
    parser.add_argument('outputfile',
                        type=str,
                        help='The name of the output file'
                        )

    sampling = parser.add_mutually_exclusive_group()
    sampling.add_argument('--samplerate',
                        dest='samplerate',
                        action='store',
                        metavar='FREQ',
                        type=lambda x: is_float(parser, x),
                        help=('Set the sample rate of the data file to FREQ. '
                              'If neither samplerate or sampletime is specified, sample rate is 1.0.'),
                        default='auto')
    sampling.add_argument('--sampletime',
                        dest='samplerate',
                        action='store',
                        metavar='TSTEP',
                        type=lambda x: invert_float(parser, x),
                        help=('Set the sample rate of the data file to 1.0/TSTEP. '
                              'If neither samplerate or sampletime is specified, sample rate is 1.0.'),
                        default='auto')
    args = parser.parse_args()

    # set the sample rate
    if args.samplerate == 'auto':
        samplerate = 25.0
    else:
        samplerate = args.samplerate

    outputfile = args.outputfile
    filelist = glob.glob(args.filespec)
    if len(filelist) == 0:
        print('filespec returned no files')
        sys.exit()
    whichfile = 0

    print('reading data...')
    alldata = {}
    numfiles = 0
    for thefile in filelist:
        alldata[thefile] = {}
        invec = tide_io.readvec(thefile)
        alldata[thefile]['timecourse'] = invec * 1.0
        alldata[thefile]['timeaxis'] = np.linspace(0.0, 1.0 * (len(invec) - 1), num=len(invec), endpoint=True) / samplerate
        alldata[thefile]['freqaxis'], alldata[thefile]['spectrum'] = \
            tide_filt.spectrum(tide_filt.hamming(len(invec)) * invec, Fs=samplerate, mode='power')
        alldata[thefile]['grade'] = None
        numfiles += 1
    print('Read in', numfiles, 'files')

        # make the main window
    app = QtGui.QApplication([])
    print("setting up output window")
    #win = QtGui.QMainWindow()
    win = KeyPressWindow()
    win.sigKeyPress.connect(keyPressed)

    ui = uiTemplate.Ui_MainWindow()
    ui.setupUi(win)
    win.show()
    win.setWindowTitle("Grader")

    # set up the regressor timecourse window
    print('about to set up the timecourse')
    global timecourse_ax
    timecoursewin = ui.timecourse_graphicsView
    timecourse_ax = timecoursewin.addPlot()

    # set up the regressor spectrum window
    print('about to set up the spectrum')
    global spectrum_ax
    spectrumwin = ui.spectrum_graphicsView
    spectrum_ax = spectrumwin.addPlot()

    updateTimecourse()

    # wire up keystrokes to control interface


    QtGui.QApplication.instance().exec_()


if __name__ == "__main__":
    main()
