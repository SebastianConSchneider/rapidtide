#!/usr/bin/env python
#
#   Copyright 2016 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# $Author: frederic $
# $Date: 2016/07/11 14:50:43 $
#       $Id: resamp1tc,v 1.12 2016/07/11 14:50:43 frederic Exp $
#

from __future__ import print_function, division

import sys
import getopt

import rapidtide.io as tide_io
import rapidtide.resample as tide_resample
from scipy import arange
from numpy import max, floor
import matplotlib.pyplot as plt


def usage():
    print("aligntcs - resample and align two time series")
    print("")
    print("usage: aligntcs infile1 insamplerate1 infile2 insamplereate2 outputfile [--nodisplay]")
    print("")
    print("required arguments:")
    print("	infile1          - the name of the text file containing the target waveform")
    print("	insamplerate1    - the sample rate of input file 1 in Hz")
    print("	infile2          - the name of the text file containing the target waveform")
    print("	insamplerate2    - the sample rate of input file 1 in Hz")
    print("	outputfile	- the name of the output text file")
    print("")
    print(" options:")
    print("     --nodisplay     - do not plot the data (for noninteractive use)")
    print("")
    return ()


def main():
    display = True

    # get the command line parameters
    nargs = len(sys.argv)
    if nargs < 6:
        usage()
        exit()
    infile1 = sys.argv[1]
    insamplerate1 = float(sys.argv[2])
    infile2 = sys.argv[3]
    insamplerate3 = float(sys.argv[4])
    outputfile = sys.argv[5]

    # now scan for optional arguments
    try:
        opts, args = getopt.getopt(sys.argv[5:], "s", ["nodisplay", "help"])
    except getopt.GetoptError as err:
        # print help information and exit:
        print(str(err))  # will print something like "option -x not recognized"
        usage()
        sys.exit(2)
    
    for o, a in opts:
        if o == "--nodisplay":
            display = False
            print('turning display off')
        else:
            assert False, "unhandled option"

    intimestep1 = 1.0 / insamplerate1
    intimestep2 = 1.0 / insamplerate2
    outtimestep = 1.0 / outsamplerate
    inputdata1 = tide_io.readvec(infile1)
    inputdata2 = tide_io.readvec(infile2)

    # determine waveform lengths
    time1 = insamplerate1 * (len(inputdata1) - 1)
    time2 = insamplerate2 * (len(inputdata2) - 1)

    fulltime = np.max([time1, time2])
    # pad waveform1 if it's shorter than waveform2
    if time1 < fulltime:
        paddeddata1 = np.zeros(int(np.ceil(fulltime // intimestep1)), dtype=float)
        paddeddata1[0:len(inputdata1) + 1] = tide_math.corrnormalize(theprefilter.apply(insamplerate1, inputdata1))
    else:
        paddeddata1 = tide_math.corrnormalize(theprefilter.apply(insamplerate1, inputdata1))

    paddeddata2 = np.zeros(int(np.ceil(fulltime // intimestep1)), dtype=float)
    if time2 < fulltime:
        
    
        
        
    numoutpoints = floor(totaltime / outtimestep) + 1

    in_t = arange(0.0, totaltime, intimestep)
    out_t = arange(0.0, outtimestep * numoutpoints, outtimestep)
    outputdata = tide_resample.doresample(in_t, inputdata, out_t, method='cubic')
    IF = max([60.0, 2.0 * insamplerate])
    if outsamplerate < insamplerate:
        outputdata2 = tide_resample.dotwostepresample(in_t, inputdata, IF, outsamplerate)
        outputdata3 = tide_resample.arbresample(inputdata, insamplerate, outsamplerate)
        print(len(out_t), len(outputdata2))
        if len(out_t) < len(outputdata2):
            outputdata2 = outputdata2[0:len(out_t)]

    if display:
        plt.plot(in_t, inputdata + 0.4, 'k')

    tide_io.writevec(outputdata, outputfile)
    tide_io.writevec(outputdata, outputfile + '_dual')
    if display:
        plt.plot(out_t, outputdata - 0.4, 'r')
        if outsamplerate < insamplerate:
            plt.plot(out_t, outputdata2 - 0.8, 'g', out_t, outputdata3 - 1.2, 'b')
            plt.legend(('original signal', 'resampled', 'dualresampled'))
        else:
            plt.legend(('original signal', 'resampled'))

    if display:
        plt.show()

if __name__ == '__main__':
    main()
