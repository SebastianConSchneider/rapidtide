#!/usr/bin/env python
# -*- coding: latin-1 -*-
#
#   Copyright 2016-2019 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
#       $Author: frederic $
#       $Date: 2016/06/14 12:04:51 $
#       $Id: spectrogram,v 1.5 2016/06/14 12:04:51 frederic Exp $
#
from __future__ import print_function, division
import datetime
import sys
import numpy as np
import matplotlib as mpl

import rapidtide.io as tide_io
import rapidtide.helper_classes as tide_classes
import matplotlib.pyplot as plt
from matplotlib import mlab
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy import arange
from scipy.signal import stft, istft, check_NOLA
import argparse

from rapidtide.workflows.parser_funcs import is_valid_file, invert_float, is_float

def _get_parser():
    """
    Argument parser for spectrogram
    """
    parser = argparse.ArgumentParser(prog='spectrogram',
                                     description='Computes and shows the spectrogram of a text file.',
                                     usage='%(prog)s textfilename samplerate [options]')

    # Required arguments
    parser.add_argument('textfilename',
                        type=lambda x: is_valid_file(parser, x),
                        help='The input data file (text file containing a timecourse, one point per line).')
    parser.add_argument('samplerate',
                        type=lambda x: is_float(parser, x),
                        help='Sample rate in Hz.')
    parser.add_argument('--nperseg',
                        dest='nperseg',
                        type=lambda x: is_int(parser, x),
                        action='store',
                        help=('The number of points to include in each spectrogram (default is 128).'),
                        default=128)
    parser.add_argument('--debug',
                        dest='debug',
                        action='store_true',
                        help=('Enable additional debugging output.'),
                        default=False)

    return parser

def ndplot(x, y, z, time, thelabel, nperseg=32):
    print("arrived in ndplot")
    fig = plt.figure()

    # -- Panel 1 Magnitude
    ax1 = fig.add_subplot(511)
    im1, cbar1 = specgram2(x, time, ax1, fig, nperseg=nperseg, mode='mag')
    ax1.set_ylabel('X Freq. $(Hz)$')
    ax1.set_title(thelabel)

    # -- Panel 2 Phase
    ax2 = fig.add_subplot(512)
    im2, cbar2 = specgram2(x, time, ax2, fig, nperseg=nperseg, mode='phase')
    ax2.set_ylabel('X Freq. $(Hz)$')
    ax2.set_title(thelabel)

    # -- Panel 3 Real
    ax3 = fig.add_subplot(513)
    im3, cbar3 = specgram2(x, time, ax3, fig, nperseg=nperseg, mode='real')
    ax3.set_ylabel('X Freq. $(Hz)$')
    ax3.set_title(thelabel)

    # -- Panel 4 Imaginary
    ax4 = fig.add_subplot(514)
    im4, cbar4 = specgram2(x, time, ax4, fig, nperseg=nperseg, mode='imag')
    ax4.set_ylabel('X Freq. $(Hz)$')
    ax4.set_title(thelabel)

    # Make an invisible spacer...
    ax5 = fig.add_subplot(515)
    cax = make_legend_axes(ax5)
    plt.setp(cax, visible=False)

    # Set the labels to be rotated at 20 deg and aligned left to use less space
    plt.setp(ax5.get_xticklabels(), rotation=-20, horizontalalignment='left')

    # Remove space between subplots
    plt.subplots_adjust(hspace=0.0)



def specgram2(x, time, ax, fig, nperseg=32, mode='mag'):
    """Make and plot a log-scaled spectrogram"""
    dt = np.diff(time)[0]  # In days...
    fs = 1.0 / dt
    NFFT = nperseg
    windowtype = 'hann'
    noverlap = (nperseg - 1)


    freq, segtimes, thestft = stft(x,
                                   fs=fs,
                                   window=windowtype,
                                   nperseg=nperseg,
                                   noverlap=noverlap,
                                   nfft=NFFT,
                                   detrend='linear',
                                   return_onesided=True,
                                   boundary='zeros',
                                   padded=True,
                                   axis=-1)

    isinvertable = check_NOLA(windowtype, nperseg, noverlap, tol=1e-10)
    print('Is invertable?', isinvertable)

    # Log scaling for amplitude values
    if mode == 'mag':
        spec_img = np.log10(np.abs(thestft))
        themax = np.max(spec_img)
        themin = themax - 3.0
    elif mode == 'phase':
        spec_img = np.log10(np.angle(thestft))
        themax = np.pi
        themin = -np.pi
    elif mode == 'real':
        spec_img = np.real(thestft)
        themax = np.max(spec_img)
        themin = np.min(spec_img)
    elif mode == 'imag':
        spec_img = np.imag(thestft)
        themax = np.max(spec_img)
        themin = np.min(spec_img)
    else:
        print('illegal spectrogram mode:', mode)
        sys.exit()

    t = np.linspace(time.min(), time.max(), spec_img.shape[1])

    # Log scaling for frequency values (y-axis)
    ax.set_yscale('log')

    # Plot amplitudes
    im = ax.pcolormesh(t, freq, spec_img, vmin=themin, vmax=themax)

    # Add the colorbar in a separate axis
    cax = make_legend_axes(ax)
    if mode == 'mag':
        cbar = fig.colorbar(im, cax=cax, format=r'$10^{%0.1f}$')
        cbar.set_label('Magnitude', rotation=-90)
    elif mode == 'phase':
        cbar = fig.colorbar(im, cax=cax, format=r'$10^{%0.1f}$')
        cbar.set_label('Phase', rotation=-90)
    elif mode == 'real':
        cbar = fig.colorbar(im, cax=cax, format=r'$10^{%0.1f}$')
        cbar.set_label('Real amplitude', rotation=-90)
    elif mode == 'imag':
        cbar = fig.colorbar(im, cax=cax, format=r'${%0.1f}$')
        cbar.set_label('Imag amplitude', rotation=-90)

    ax.set_ylim([freq[1], freq.max()])

    # Hide x-axis tick labels
    plt.setp(ax.get_xticklabels(), visible=False)

    return im, cbar


def specgram(x, time, ax, fig, nperseg=32):
    """Make and plot a log-scaled spectrogram"""
    dt = np.diff(time)[0]  # In days...
    fs = 1.0 / dt
    NFFT = nperseg

    spec_img, freq, _ = mlab.specgram(x,
                                      Fs=fs,
                                      detrend='linear',
                                      NFFT=NFFT,
                                      window=np.hamming(NFFT),
                                      noverlap=(nperseg - 1))
    print(spec_img.shape, freq.shape)
    freqtracker = tide_classes.freqtrack(nperseg=nperseg)
    thetimes, thefreqs = freqtracker.track(x, fs)
    tide_io.writevec(thefreqs, 'peakfreaks.txt')
    print(thefreqs)
    cleandata = freqtracker.clean(x, fs, thetimes, thefreqs)
    tide_io.writevec(cleandata, 'cleaneddata.txt')
    t = np.linspace(time.min(), time.max(), spec_img.shape[1])

    # Log scaling for amplitude values
    spec_img = np.log10(spec_img)

    # set range
    themax = np.max(spec_img)
    themin = themax - 6.0

    # Log scaling for frequency values (y-axis)
    ax.set_yscale('log')

    # Plot amplitudes
    im = ax.pcolormesh(t, freq, spec_img, vmin=themin, vmax=themax)

    # Add the colorbar in a seperate axis
    cax = make_legend_axes(ax)
    cbar = fig.colorbar(im, cax=cax, format=r'$10^{%0.1f}$')
    cbar.set_label('Amplitude', rotation=-90)

    ax.set_ylim([freq[1], freq.max()])

    # Hide x-axis tick labels
    plt.setp(ax.get_xticklabels(), visible=False)

    return im, cbar


def make_legend_axes(ax):
    divider = make_axes_locatable(ax)
    legend_ax = divider.append_axes('right', 0.4, pad=0.2)
    return legend_ax


def main():
    # get the command line parameters
    try:
        args = _get_parser().parse_args()
    except SystemExit:
        _get_parser().print_help()
        raise
    if args.debug:
        print(args)

    # handle required args first
    textfilename = []
    xvecs = []
    yvecs = []
    timestep = []
    numfiles = 1
    textfilename.append(args.textfilename)
    timestep.append(1.0 / args.samplerate)

    for i in range(0, numfiles):
        print('filename ', i, textfilename[i])
        yvecs.append(tide_io.readvec(textfilename[i]))
        xvecs.append(arange(0.0, len(yvecs[i]), 1.0) * timestep[i])

    print("got to here")

    # -- Make a series of dates
    start = datetime.datetime(2010, 9, 15, 8, 0)
    end = datetime.datetime(2010, 9, 15, 18, 0)
    delta = datetime.timedelta(seconds=1)

    # Note: "time" is now an array of floats, where 1.0 corresponds
    # to one day, and 0.0 corresponds to 1900 (I think...)
    # It's _not_ an array of datetime objects!
    time = mpl.dates.drange(start, end, delta)

    # -- Generate some data
    x = yvecs[0]
    y = yvecs[0]
    z = yvecs[0]

    thelabel = textfilename[0]
    ndplot(x, y, z, xvecs[0], thelabel, nperseg=args.nperseg)
    plt.show()


if __name__ == '__main__':
    main()
