#!/usr/bin/env python
#
#   Copyright 2016 Blaise Frederick
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
#
# $Author: frederic $
#       $Date: 2016/07/11 14:50:43 $
#       $Id: showtc,v 1.16 2016/07/11 14:50:43 frederic Exp $
#
from __future__ import print_function
import sys
import platform
import getopt
from cycler import cycler

import matplotlib
import matplotlib.cm as cm

import rapidtide.tide_funcs as tide
import numpy as np
from scipy import arange, fftpack

from pylab import figure, plot, legend, show, xlabel, ylabel, savefig, title, subplot, tight_layout, suptitle, xlim, ylim


def phase(mcv): 
    return np.arctan2(mcv.imag, mcv.real) 


def usage():
    print("showtc - plots the data in text files")
    print("")
    print("usage: showtc texfilename [textfilename]... [--nolegend] [--pspec] [--phase] [--samplerate=Fs] [--sampletime=Ts]")
    print("")
    print("required arguments:")
    print("    textfilename	- a text file containing whitespace separated timecourses, one timepoint per line")
    print("")
    print("optional arguments:")
    print("    --nolegend               - turn off legend label")
    print("    --pspec                  - show the power spectra magnitudes of the input data instead of the timecourses")
    print("    --phase                  - show the power spectra phases of the input data instead of the timecourses")
    print("    --transpose              - swap rows and columns in the input files")
    print("    --waterfall              - plot multiple timecourses as a waterfall")
    print("    --voffset=VOFFSET        - plot multiple timecourses as with VOFFSET between them (use negative VOFFSET to set automatically)")
    print("    --samplerate=Fs          - the sample rate of the input data is Fs Hz (default is 1Hz)")
    print("    --sampletime=Ts          - the sample time (1/samplerate) of the input data is Ts seconds (default is 1s)")
    print("    --colorlist=C1,C2,..     - cycle through the list of colors specified by CN")
    print("    --linewidth=LW           - set linewidth to LW points (default is 1)")
    print("    --legendlist=L1,L2,..    - cycle through the list of legends specified by LN")
    print("    --tofile=FILENAME        - write figure to file FILENAME instead of displaying on the screen")
    print("    --title=TITLE            - use TITLE as the overall title of the graph")
    print("    --separate               - use a separate subplot for each timecourse")
    return ()

# set default variable values
dolegend = True
dotranspose = False
dowaterfall = False
dopspec = False
detrend = True
useHamming = True
domag = True
samplerate = 1.0
voffset = 0.0
colornames = []
outputfile = None
thetitle = None
legendlist = []
separate = False
thelinewidth = 1.0

# get the command line parameters
try:
    opts, args = getopt.gnu_getopt(sys.argv, "F", ["help", "nolegend", "pspec", "phase", "transpose", "waterfall", "voffset=",
                                                   "samplerate=", "colorlist=", "linewidth=", "legendlist=", "title=", "separate", "sampletime=", "tofile="])
except getopt.GetoptError as err:
    # print help information and exit:
    print(str(err))  # will print something like 'option -a not recognized'
    usage()
    sys.exit(2)

# check for filename arguments
nargs = len(args)
if nargs < 2:
    usage()
    sys.exit(1)

# now parse options
for o, a in opts:
    linkchar = ' '
    if o == "--nolegend":
        dolegend = False
        print('turning off legend label')
    elif o == '--separate':
        separate = True
        print('put each plot in a separate window')
    elif o == '--pspec':
        dopspec = True
        domag = True
        print('showing power spectra magnitude')
    elif o == '--tofile':
        outputfile = a
        print('Writing output to file', outputfile)
    elif o == '--legendlist':
        for thislegend in a.split(','):
            legendlist.append(thislegend)
        print('Colors used:', colornames)
    elif o == '--linewidth':
        thelinewidth = float(a)
        print('Linewidth set to:', thelinewidth)
    elif o == '--colorlist':
        for thiscolor in a.split(','):
            colornames.append(thiscolor)
        print('Colors used:', colornames)
    elif o == '--phase':
        dopspec = True
        domag = False
        print('showing power spectra phase')
    elif o == '--waterfall':
        dowaterfall = True
        print('making a waterfall plot')
    elif o == '--transpose':
        dotranspose = True
        print('transposing input data')
    elif o == '--samplerate':
        samplerate = float(a)
        linkchar = '='
        print('Samplerate set to ', samplerate)
    elif o == '--title':
        thetitle = a
        linkchar = '='
        print('Will use title', thetitle)
    elif o == '--voffset':
        voffset = float(a)
        linkchar = '='
        print('Vertical offset set to ', voffset)
    elif o == '--sampletime':
        samplerate = 1.0 / float(a)
        linkchar = '='
        print('Samplerate set to ', samplerate)
    elif o == '-F':
        print('got the -F option')
    elif o in ('-h', '--help'):
        usage()
        sys.exit()
    else:
        assert False, 'unhandled option'

# handle required args first
textfilename = []
xvecs = []
yvecs = []
linelabels = []
numfiles = 1
numvecs = 0
#textfilename.append(sys.argv[1])
textfilename.append(args[1])
if nargs > 2:
    for i in range(2, nargs):
        numfiles += 1
        textfilename.append(args[i])

# read in all the data
for i in range(0, numfiles):
    print('filename ', i, textfilename[i])
    if dotranspose:
        invecs = np.transpose(tide.readvecs(textfilename[i]))
    else:
        invecs = tide.readvecs(textfilename[i])
    print('   ', invecs.shape[0], ' columns')
    for j in range(0, invecs.shape[0]):
        print('appending vector number ', j)
        if dopspec:
            if invecs.shape[1] % 2 == 1:
                invec = invecs[j, :-1]
            else:
                invec = invecs[j, :]
            if detrend:
                invec = tide.detrend(invec, order=1, demean=True)
            elif demean:
                invec = invec = mean(invec)
            if useHamming:
                pspec = fftpack.fft(tide.hamming(len(invec)) * invec)[0:len(invec) // 2]
            else:
                pspec = fftpack.fft(invec)[0:len(invec) // 2]
            if domag:
                #yvecs.append(abs(pspec) + numvecs * voffset)
                yvecs.append(abs(pspec) * 1.0)
            else:
                #yvecs.append(phase(pspec) + numvecs * voffset)
                yvecs.append(phase(pspec) * 1.0)
            maxfreq = samplerate / 2.0
            xvecs.append(arange(0.0, maxfreq, maxfreq / (len(yvecs[i]))))
        else:
            #yvecs.append(invecs[j] + numvecs * voffset)
            yvecs.append(invecs[j] * 1.0)
            xvecs.append(arange(0.0, len(yvecs[numvecs]), 1.0) / samplerate)
        if len(legendlist) == 0:
            if invecs.shape[0] > 1:
                linelabels.append(textfilename[i] + '_column' + str(j).zfill(2))
            else:
                linelabels.append(textfilename[i])
        else:
            if invecs.shape[0] > 1:
                linelabels.append(legendlist[i % len(legendlist)] + '_column' + str(j).zfill(2))
            else:
                linelabels.append(legendlist[i % len(legendlist)])
        numvecs += 1

xrange = (np.min(np.asarray(xvecs, dtype='float')), np.max(np.asarray(xvecs, dtype='float')))
yrange = (np.min(np.asarray(yvecs, dtype='float')), np.max(np.asarray(yvecs, dtype='float')))
if voffset < 0.0:
    voffset = yrange[1] - yrange[0]
for i in range(0, numvecs):
    yvecs[i] += (numvecs - i - 1) * voffset
yrange = (np.min(np.asarray(yvecs, dtype='float')), np.max(np.asarray(yvecs, dtype='float')))

if dowaterfall:
    xstep = (xrange[1] - xrange[0])/numvecs
    ystep = yrange[1] - yrange[0]
    for i in range(numvecs):
        xvecs[i] = xvecs[i] + i * xstep
        yvecs[i] = 10.0 * yvecs[i]/ystep + i * ystep


# now plot it out
if separate:
    thexaxfontsize = 6
    theyaxfontsize = 6
    thexlabelfontsize = 4
    theylabelfontsize = 4
    thelegendfontsize = 6
    thetitlefontsize = 6
    thesuptitlefontsize = 10
else:
    thexaxfontsize = 10
    theyaxfontsize = 10
    thexlabelfontsize = 10
    theylabelfontsize = 10
    thelegendfontsize = 8
    thetitlefontsize = 10
    thesuptitlefontsize = 10

if len(colornames) > 0:
    colorlist = [colornames[i % len(colornames)] for i in range(numvecs)]
else:
    colorlist = [cm.spectral(float(i) / numvecs) for i in range(numvecs)]

fig = figure()
if separate:
    fig.suptitle(thetitle, fontsize=thesuptitlefontsize)
else:
    ax = fig.add_subplot(1, 1, 1)
    ax.set_title(thetitle, fontsize=thetitlefontsize)
for i in range(0, numvecs):
    if separate:
        ax = fig.add_subplot(numvecs, 1, i + 1)
    ax.plot(xvecs[i], yvecs[i], color=colorlist[i], label=linelabels[i], linewidth=thelinewidth)
    ax.set_ylim(yrange)
    ax.tick_params(axis='x', labelsize=thexlabelfontsize, which='both')
    ax.tick_params(axis='y', labelsize=theylabelfontsize, which='both')
    if separate and (thetitle is not None):
        ax.set_title(legendlist[i], loc='right', fontsize=thetitlefontsize)
if not separate:
    if dolegend:
        ax.legend(fontsize=thelegendfontsize)

if dopspec:
    ax.set_xlabel('Frequency (Hz)', fontsize=thexlabelfontsize, fontweight='bold')
    if domag:
        ax.set_ylabel('Signal power', fontsize=theylabelfontsize, fontweight='bold')
    else:
        ax.set_ylabel('Signal phase', fontsize=theylabelfontsize, fontweight='bold')
else:
    ax.set_xlabel('Time (s)', fontsize=thexlabelfontsize, fontweight='bold')


fig.tight_layout()

if outputfile is None:
    fig.show()
else:
    savefig(outputfile, bbox_inches='tight')
