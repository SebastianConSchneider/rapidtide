#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jun 28 20:01:29 2018

@author: neuro
"""

import matplotlib.pyplot as plt
import dataload as dl
import numpy as np
from keras.models import model_from_json
from scipy import fftpack
import rapidtide.io as tide_io
import os
import json


def spectrum(inputdata, Fs):
    pspecvals = fftpack.fft(inputdata)[0:len(inputdata) // 2]
    maxfreq = Fs / 2.0
    pspecaxis = np.linspace(0.0, maxfreq, len(pspecvals), endpoint=False)
    return pspecaxis, pspecvals


# set initial parameters
modelname = 'model'

'''
# Model reconstruction from JSON file
print('reading model')
with open(modelname + '.json', 'r') as f:
    model = model_from_json(f.read())
print('./model read')
model.summary()

# now load weights
model.load_weights('./' + modelname + '_weights.h5')
'''

# load the model with weights
model.load(os.path.join('.', modelname + '.h5')

# now load additional information
print('reading metadata')
model_meta = tide_io.readdictfromjson(modelname + '_meta.json')
print('./model_meta read')

lag = model_meta['lag']
window_size = model_meta['window_size']
dofft = model_meta['dofft']
if dofft == 1:
    dofft = True
else:
    dofft = False

# read in the dataset
thedatadir = '/Users/frederic/Documents/MR_data/physioconn/timecourses'
if dofft:
    train_x, train_y, val_x, val_y, Ns, tclen, Xscale, Yscale = dl.prep(window_size, thesuffix='25.0Hz', thedatadir=thedatadir, dofft=True)
else:
    train_x, train_y, val_x, val_y, Ns, tclen = dl.prep(window_size, thesuffix='25.0Hz', thedatadir=thedatadir, dofft=False)

YPred2 = model.predict(val_x)
length = (tclen - window_size - 1)

K = 5 
print('shape of val_x:', val_x.shape)
val_x = val_x[-K * length:, :, :]
val_y = val_y[-K * length:, :, :]
YPred2 = YPred2[-K * length:, :, :]


YPred2_val = YPred2.reshape(K, -1, (window_size + lag), val_y.shape[2])
val_y_val  = val_y.reshape(K, -1, (window_size + lag), val_y.shape[2])
val_x_val  = val_x.reshape(K, -1, (window_size + lag), val_x.shape[2])
print('val_y_val shape:', val_y_val.shape)

Nv = val_y_val.shape[1] - window_size
Ns = K
output_pred = np.zeros([Ns, Nv + window_size])
output_pred2 = output_pred + 0.0
output_real = np.zeros([Ns, Nv + window_size])
output_raw = np.zeros([Ns, Nv + window_size])

for k in range(Ns):
    print(k)
    for i in range(0, Nv):
        if dofft:
            output_pred[k, i:(i + window_size)] += dl.filtscale(YPred2_val[k, i, :, :], scalefac=1.0, reverse=True)
            output_real[k, i:(i + window_size)] += dl.filtscale(val_y_val[k, i, :, :], scalefac=Yscale[k, i], reverse=True)
            output_raw[k, i:(i + window_size)] += dl.filtscale(val_x_val[k, i, :, :], scalefac=Xscale[k, i], reverse=True)
        else:
            output_pred[k, i:(i + window_size)] += YPred2_val[k, i, :, 0]
            output_real[k, i:(i + window_size)] += val_y_val[k, i, :, 0]
            output_raw[k, i:(i + window_size)] += val_x_val[k, i, :, 0]

output_pred /= window_size
output_real /= window_size
output_raw /= window_size

error_s = output_real - output_pred
sq_error_s = (np.mean(np.square(error_s), axis=1))

error2_s = output_raw - output_real
sq_error2_s = (np.mean(np.square(error2_s), axis=1))

'''
import getphase as gp3

thephase_pred_temp = gp3.phasefromwave(output_pred[1, :], 12.5)

thephase_pred = np.zeros([K, thephase_pred_temp.shape[0]])
thephase_real = np.zeros([K, thephase_pred_temp.shape[0]])
thephase_raw = np.zeros([K, thephase_pred_temp.shape[0]])

# for i in range(7):
c2 = 0
for c, i in enumerate(range(K)):
    print(i)
    if (i != 9) and (i != 10) and (i != 11):
        thephase_pred[c2, :] = gp3.phasefromwave(output_pred[i, :], 12.5)
        thephase_raw[c2, :] = gp3.phasefromwave(output_raw[i, :], 12.5)
        thephase_real[c2, :] = gp3.phasefromwave(output_real[i, :], 12.5)
        c2 = c2 + 1

# error1=np.square(thephase_pred-thephase_real)
# error2=np.square(thephase_raw-thephase_real)

#
# for i in range(K2):
#    for j in range(error1.shape[1]):
#        error1[i,j]=math.fmod(error1[i,j]+math.pi,2*math.pi)-math.pi
#        error2[i,j]=math.fmod(error2[i,j]+math.pi,2*math.pi)-math.pi 


error1 = (thephase_pred - thephase_real)
error2 = (thephase_raw - thephase_real)

error1 = error1[:-3, :]
error2 = error2[:-3, :]
K2 = K - 3
import math

for i in range(K2):
    for j in range(error1.shape[1]):
        error1[i, j] = math.fmod(error1[i, j], 2 * math.pi)
        error2[i, j] = math.fmod(error2[i, j], 2 * math.pi)

for i in range(K2):
    for j in range(error1.shape[1]):
        if (error1[i, j] > math.pi):
            error1[i, j] = error1[i, j] - 2 * math.pi
        if (error2[i, j] > math.pi):
            error2[i, j] = error2[i, j] - 2 * math.pi

for i in range(K2):
    for j in range(error1.shape[1]):
        if (error1[i, j] < - math.pi):
            error1[i, j] = error1[i, j] + 2 * math.pi
        if (error2[i, j] < - math.pi):
            error2[i, j] = error2[i, j] + 2 * math.pi

error1 = error1 - np.mean(error1, axis=1)[:, None]
error2 = error2 - np.mean(error2, axis=1)[:, None]

e1 = np.mean(np.square(error1), axis=1)
e2 = np.mean(np.square(error2), axis=1)

s1 = np.std(np.square(error1), axis=1)
s2 = np.std(np.square(error2), axis=1)

for i in range(K2):
    plt.plot(error1[i, :])
    plt.plot(error2[i, :])
    plt.legend(['pred', 'raw'])

    plt.show()

for i in range(K2):
    plt.close()
    plt.plot(thephase_pred[i, :])
    # plt.plot(thephase_real[i,:])
    plt.plot(thephase_raw[i, :])
    plt.show()

# np.mean(e1[:,100:-100],axis=1)
# np.mean(e2[:,100:-100],axis=1)
e1_c = np.mean(np.square(error1[:, 100:-100]), axis=1)
e2_c = np.mean(np.square(error2[:, 100:-100]), axis=1)
'''


for s in range(K):
    plt.plot(output_pred[s, :])
    plt.plot(output_real[s, :])
    plt.plot(output_raw[s, :])
    plt.legend(['pred', 'groundtruth', 'raw'])
    plt.show()
    tide_io.writevec(output_pred[s, :], './thepred' + str(s).zfill(2) + '.txt')
    tide_io.writevec(output_real[s, :], './thereal' + str(s).zfill(2) + '.txt')
    tide_io.writevec(output_raw[s, :], './theraw' + str(s).zfill(2) + '.txt')



plt.figure()
plt.plot(singlepred)
plt.plot(singlereal)
plt.plot(singleraw)
plt.legend(['pred2', 'groundtruth', 'raw'])
plt.show()

from scipy.stats import pearsonr

p2g = np.zeros(K)
r2g = np.zeros(K)

for s in range(K):
    p2g[s] = pearsonr(output_pred[s, :], output_real[s, :])[0]
    r2g[s] = pearsonr(output_raw[s, :], output_real[s, :])[0]
    # print('Prediction:',p2g[s],'    Raw:',r2g[s] )
    print('Prediction:', (1 - np.square(p2g[s])) * 100, '    Raw:', (1 - np.square(r2g[s]) * 100))

output_x, output_y = spectrum(output_pred[s, :], 12.5)
output_real_x, output_real_y = spectrum(output_real[s, :], 12.5)
output_raw_x, output_raw_y = spectrum(output_raw[s, :], 12.5)
plt.plot(output_x, np.abs(output_y))
plt.plot(output_real_x, np.abs(output_real_y))
plt.plot(output_raw_x, np.abs(output_raw_y))
plt.legend(['pred', 'groundtruth', 'raw'])
# plt.legend([ 'raw','groundtruth'])
plt.show()

YPred = model.predict(val_x)

error = val_y - YPred
sq_error = (np.mean(np.square(error)))

error2 = val_x - val_y
sq_error2 = (np.mean(np.square(error2)))

print(sq_error)
print(sq_error2)

#
# output=np.zeros(1600)
# output_real=np.zeros(1600)
# output_raw=np.zeros(1600)
# for i in range(0,1500):
#    output[i:i+31]+=YPred2[i,:,0]
#    output_real[i:i+31]+=val_y[i,:,0]
#    output_raw[i:i+31]+=val_x[i,:,0]
#
# output/=31
# output_real/=31
# output_raw/=31
#
# output=output-np.mean(output[31:1500])
# output=output/np.std(output[31:1500])
# output_real=output_real-np.mean(output_real[31:1500])
# output_real=output_real/np.std(output_real[31:1500])
# output_raw=output_raw-np.mean(output_raw[31:1500])
# output_raw=output_raw/np.std(output_raw[31:1500])
# plt.plot(output)
# plt.plot(output_real)
# plt.plot(output_raw)
# plt.legend(['pred', 'groundtruth','raw'])
# plt.show()
##
##plt.plot(YPred[0,:,0])
##plt.plot(Y[0,:,0])
##plt.plot(X[0,:,0])
##plt.legend(['pred', 'groundtruth', 'raw'])
##plt.show()
#
#
# loss = history.history['loss']
# val_loss = history.history['val_loss']
#
# epochs = range(len(loss))
##
# plt.figure()
#
# plt.plot(epochs, loss, 'bo', label='Training loss')
# plt.plot(epochs, val_loss, 'b', label='Validation loss')
# plt.title('Training and validation loss')
# plt.legend()
#
# plt.show()
##
